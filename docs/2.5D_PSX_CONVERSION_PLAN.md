# 2.5D PSX Backrooms Conversion Plan

**Project**: Backrooms Power Crawl
**Target**: Third-person 2.5D with PSX aesthetic and VHS post-processing
**Status**: Planning
**Created**: 2025-11-08

---

## Executive Summary

This document outlines the complete conversion of our 2D turn-based roguelike to a 2.5D PSX-styled Backrooms horror game. The conversion preserves our existing architecture (InputManager, State Machine, Action Pattern) while adding:

- **3D environment** with GridMap-based grid system
- **Third-person camera** (Fortnite-style) with tactical controls
- **PSX visual style** (vertex jitter, affine textures, low-res)
- **Backrooms aesthetic** (yellow walls, fluorescent lights, liminal horror)
- **VHS post-processing** (scanlines, chromatic aberration, grain)
- **Billboard character sprites** (emoji style, always face camera)

**Key Principle**: Our turn-based architecture is excellent and requires minimal changes. Most work is visual/environmental.

---

## Current State Analysis

### What We Have (2D)

**Architecture** âœ… SOLID
- InputManager autoload (controller + keyboard abstraction)
- State Machine (IdleState, AimingMoveState, ExecutingTurnState)
- Action Pattern (MovementAction, WaitAction with can_execute/execute)
- Grid system (128x128 with viewport culling)
- Turn counter and position tracking

**Files**:
```
/scripts/
  â”œâ”€â”€ autoload/input_manager.gd
  â”œâ”€â”€ player/
  â”‚   â”œâ”€â”€ input_state_machine.gd
  â”‚   â”œâ”€â”€ player.gd
  â”‚   â””â”€â”€ states/ (idle, aiming, executing)
  â”œâ”€â”€ actions/ (movement_action, wait_action, action base)
  â”œâ”€â”€ grid.gd
  â””â”€â”€ game.gd

/scenes/
  â”œâ”€â”€ game.tscn (Node2D hierarchy)
  â””â”€â”€ main_menu.tscn
```

**Coordinate System**:
- Grid positions: `Vector2i`
- World positions: `Vector2` (via `grid_to_world()`)
- Camera: `Camera2D` top-down
- Rendering: 2D Labels for tiles, emoji for player

### What Changes (3D)

**Node Types**:
- `Node2D` â†’ `Node3D`
- `Camera2D` â†’ `Camera3D` (with third-person rig)
- `Label` (tiles) â†’ `GridMap` (3D mesh instances)
- `Label` (player) â†’ `Sprite3D` (billboard mode)

**Coordinate Mapping**:
- Grid positions: `Vector2i` (UNCHANGED)
- World positions: `Vector3` (Y = height, typically 0)
- Conversion: `(x, y)` â†’ `(x, 0, y)` in 3D space

**Visual Pipeline**:
```
3D Scene â†’ PSX Shaders â†’ Camera3D â†’ VHS Post-Process â†’ Screen
```

---

## Phase Breakdown

### Phase 1: 3D Foundation (GridMap + Coordinates)
**Goal**: Get basic 3D grid working with player movement

### Phase 2: Third-Person Camera Rig
**Goal**: Implement Fortnite-style camera with rotation and zoom

### Phase 3: PSX Shader Integration
**Goal**: Apply MenacingMecha's PSX shaders to environment

### Phase 4: Backrooms Environment
**Goal**: Yellow walls, fluorescent lights, liminal aesthetic

### Phase 5: Billboard Characters
**Goal**: Convert emoji sprites to Sprite3D billboards

### Phase 6: VHS Post-Processing
**Goal**: Add scanlines, grain, chromatic aberration

### Phase 7: Procedural Generation
**Goal**: Infinite yellow hallways with variation

### Phase 8: Polish & Balance
**Goal**: Tune visibility, performance, atmosphere vs clarity

---

## Phase 1: 3D Foundation (GridMap + Coordinates)

### 1.1 Create New 3D Scene Structure

**New file**: `/scenes/game_3d.tscn`

```
Node3D (Game)
â”œâ”€ WorldEnvironment
â”œâ”€ DirectionalLight3D (ambient base light)
â”œâ”€ Grid3D (Node3D)
â”‚  â””â”€ GridMap
â”œâ”€ Player3D (CharacterBody3D)
â”‚  â”œâ”€ CollisionShape3D
â”‚  â”œâ”€ Model (Sprite3D) - emoji billboard
â”‚  â””â”€ CameraRig (Node3D)
â”‚     â””â”€ HorizontalPivot (Node3D)
â”‚        â””â”€ VerticalPivot (Node3D)
â”‚           â””â”€ SpringArm3D
â”‚              â””â”€ Camera3D
â””â”€ UI (CanvasLayer)
   â”œâ”€ TurnCounter (Label)
   â””â”€ Instructions (Label)
```

### 1.2 Create Grid3D Class

**New file**: `/scripts/grid_3d.gd`

```gdscript
class_name Grid3D
extends Node3D
## 3D grid system using GridMap for tile-based world
##
## Maintains same logical grid (Vector2i) as 2D version,
## but renders in 3D space using GridMap.

# Grid configuration
const GRID_SIZE := Vector2i(128, 128)
const CELL_SIZE := Vector3(1.0, 0.5, 1.0)  # X, Y (height), Z

# GridMap reference
@onready var grid_map: GridMap = $GridMap

# Grid data (same as 2D version)
var grid_size: Vector2i = GRID_SIZE
var walkable_cells: Array[Vector2i] = []

# MeshLibrary item IDs
enum TileType {
	FLOOR = 0,
	WALL = 1,
	CEILING = 2,
}

# ============================================================================
# LIFECYCLE
# ============================================================================

func _ready() -> void:
	grid_map.cell_size = CELL_SIZE
	print("[Grid3D] Initialized: %d x %d" % [grid_size.x, grid_size.y])

func initialize(size: Vector2i) -> void:
	"""Initialize grid with given size"""
	grid_size = size
	_generate_grid()

# ============================================================================
# GRID GENERATION
# ============================================================================

func _generate_grid() -> void:
	"""Generate 3D grid using GridMap"""
	# For now, create simple open area with walls around edges
	# TODO: Replace with Backrooms procedural generation

	for y in range(grid_size.y):
		for x in range(grid_size.x):
			var pos = Vector2i(x, y)
			var is_edge = x == 0 or x == grid_size.x - 1 or y == 0 or y == grid_size.y - 1

			if is_edge:
				# Place wall
				grid_map.set_cell_item(Vector3i(x, 0, y), TileType.WALL)
			else:
				# Place floor
				grid_map.set_cell_item(Vector3i(x, 0, y), TileType.FLOOR)
				walkable_cells.append(pos)

# ============================================================================
# COORDINATE CONVERSION
# ============================================================================

func grid_to_world(grid_pos: Vector2i) -> Vector3:
	"""Convert 2D grid coordinates to 3D world position"""
	# Use GridMap's built-in conversion
	var cell_3d = Vector3i(grid_pos.x, 0, grid_pos.y)
	return grid_map.map_to_local(cell_3d)

func world_to_grid(world_pos: Vector3) -> Vector2i:
	"""Convert 3D world position to 2D grid coordinates"""
	var cell_3d = grid_map.local_to_map(world_pos)
	return Vector2i(cell_3d.x, cell_3d.z)

# ============================================================================
# GRID QUERIES (Same API as 2D version)
# ============================================================================

func is_walkable(pos: Vector2i) -> bool:
	"""Check if grid position is walkable"""
	if not is_in_bounds(pos):
		return false

	var cell_item = grid_map.get_cell_item(Vector3i(pos.x, 0, pos.y))
	return cell_item == TileType.FLOOR

func is_in_bounds(pos: Vector2i) -> bool:
	"""Check if position is within grid bounds"""
	return pos.x >= 0 and pos.x < grid_size.x and \
	       pos.y >= 0 and pos.y < grid_size.y

func get_random_walkable_position() -> Vector2i:
	"""Get random walkable position"""
	if walkable_cells.is_empty():
		return Vector2i(grid_size.x / 2, grid_size.y / 2)
	return walkable_cells.pick_random()
```

### 1.3 Create MeshLibrary

**New file**: Create in Godot Editor

**Steps**:
1. Create new Scene: `res://assets/mesh_library.tscn`
2. Add Node3D as root
3. Add child MeshInstance3D nodes for each tile type:

```
MeshLibrary (Node3D)
â”œâ”€ Floor (MeshInstance3D)
â”‚  â””â”€ Mesh: PlaneMesh (1x1)
â”‚  â””â”€ Material: StandardMaterial3D (yellow-ish)
â”œâ”€ Wall (MeshInstance3D)
â”‚  â””â”€ Mesh: BoxMesh (1x1x1)
â”‚  â””â”€ Material: StandardMaterial3D (yellow wallpaper)
â””â”€ Ceiling (MeshInstance3D)
   â””â”€ Mesh: PlaneMesh (1x1, rotated 180Â°)
   â””â”€ Material: StandardMaterial3D (ceiling tile)
```

4. In Godot Editor: Scene â†’ Export As â†’ MeshLibrary
5. Save as `res://assets/grid_mesh_library.tres`

**Assign to GridMap**:
- Select GridMap node in game_3d.tscn
- Inspector â†’ Mesh Library â†’ Load `grid_mesh_library.tres`
- Cell Size: (1, 0.5, 1)

### 1.4 Update Player for 3D

**New file**: `/scripts/player/player_3d.gd`

```gdscript
class_name Player3D
extends CharacterBody3D
## 3D player controller for turn-based movement
##
## Maintains same grid-based logic as 2D version,
## but operates in 3D space with smooth interpolation.

# Movement configuration
const MOVE_DURATION := 0.2  # Smooth movement animation time

# Grid state (SAME AS 2D VERSION)
var grid_position: Vector2i = Vector2i(64, 64)
var movement_target: Vector2i = Vector2i.ZERO
var pending_action = null
var turn_count: int = 0

# 3D-specific state
var target_world_position: Vector3
var is_moving: bool = false

# Node references
@onready var grid: Grid3D = get_node("/root/Game/Grid3D")
@onready var model: Sprite3D = $Model
@onready var state_machine = $InputStateMachine

# ============================================================================
# LIFECYCLE
# ============================================================================

func _ready() -> void:
	# Start at center of grid
	grid_position = Vector2i(grid.grid_size.x / 2, grid.grid_size.y / 2)
	update_visual_position()
	print("[Player3D] Ready at position: ", grid_position)

func _unhandled_input(event: InputEvent) -> void:
	# Delegate to state machine
	if state_machine:
		state_machine.handle_input(event)

func _process(delta: float) -> void:
	# Delegate to state machine
	if state_machine:
		state_machine.process_frame(delta)

	# Smooth movement animation
	if is_moving:
		global_position = global_position.move_toward(
			target_world_position,
			10.0 * delta  # Movement speed
		)

		if global_position.distance_to(target_world_position) < 0.01:
			global_position = target_world_position
			is_moving = false

# ============================================================================
# MOVEMENT (SAME API AS 2D VERSION)
# ============================================================================

func update_visual_position() -> void:
	"""Update 3D position to match grid position"""
	target_world_position = grid.grid_to_world(grid_position)

	# Start smooth movement
	if global_position.distance_to(target_world_position) > 0.1:
		is_moving = true
	else:
		global_position = target_world_position

# ============================================================================
# MOVEMENT INDICATOR (Adapted for 3D)
# ============================================================================

func update_move_indicator() -> void:
	"""Show movement preview (TODO: 3D indicator)"""
	# For now, just show it
	# TODO: Create 3D arrow or highlight target tile
	pass

func hide_move_indicator() -> void:
	"""Hide movement preview"""
	pass
```

### 1.5 Update Game Scene for 3D

**Modify**: `/scripts/game.gd`

```gdscript
extends Node3D  # Changed from Node2D
## Main game scene - 3D version

@onready var grid: Grid3D = $Grid3D  # Changed from Grid
@onready var player: Player3D = $Player3D  # Changed from Player
@onready var ui_turn_counter: Label = $UI/TurnCounter
@onready var ui_instructions: Label = $UI/Instructions

func _ready() -> void:
	print("[Game] Initializing 3D turn-based roguelike...")

	# Initialize grid
	grid.initialize(Grid3D.GRID_SIZE)

	# Link player to grid
	player.grid = grid

	print("[Game] Ready! Controls: Left stick/WASD to aim, RT/Space to move")

func _process(_delta: float) -> void:
	# Update UI (same as 2D version)
	if player and player.state_machine:
		ui_turn_counter.text = "Turn: %d | Pos: %s | State: %s" % [
			player.turn_count,
			player.grid_position,
			player.state_machine.get_current_state_name()
		]
```

### 1.6 Testing Checklist

- [ ] Game scene loads without errors
- [ ] Player spawns at center of grid (64, 64)
- [ ] Grid appears as 3D floor tiles
- [ ] Wall tiles surround the edges
- [ ] Player can move with WASD/stick (even if camera is bad)
- [ ] Turn counter updates
- [ ] Grid positions match 2D behavior

**Expected Result**: Basic 3D grid with working turn-based movement (camera will be bad, fix in Phase 2).

---

## Phase 2: Third-Person Camera Rig

### 2.1 Camera Node Structure

Already set up in Phase 1 scene structure:

```
Player3D
â””â”€ CameraRig (Node3D) - follows player
   â””â”€ HorizontalPivot (Node3D) - rotation around Y-axis
      â””â”€ VerticalPivot (Node3D) - pitch angle
         â””â”€ SpringArm3D - collision avoidance
            â””â”€ Camera3D - actual camera
```

### 2.2 Create TacticalCamera Script

**New file**: `/scripts/player/tactical_camera.gd`

```gdscript
class_name TacticalCamera
extends Node3D
## Third-person tactical camera for turn-based gameplay
##
## Features:
## - Fortnite-style third-person view
## - Zoom with mouse wheel / shoulder buttons
## - 45Â° rotation snapping for tactical clarity
## - Smooth transitions with tweens

# Camera configuration
@export var default_distance: float = 15.0
@export var default_pitch: float = -45.0  # Look down angle
@export var default_yaw: float = 45.0     # Starting rotation

# Camera control
@export var zoom_speed: float = 2.0
@export var zoom_min: float = 8.0
@export var zoom_max: float = 25.0
@export var rotation_snap: float = 45.0  # Snap to 45Â° increments

# Zoom-based pitch adjustment
@export var pitch_near: float = -30.0   # When zoomed in
@export var pitch_far: float = -60.0    # When zoomed out

# Node references
@onready var h_pivot: Node3D = $HorizontalPivot
@onready var v_pivot: Node3D = $HorizontalPivot/VerticalPivot
@onready var spring_arm: SpringArm3D = $HorizontalPivot/VerticalPivot/SpringArm3D
@onready var camera: Camera3D = $HorizontalPivot/VerticalPivot/SpringArm3D/Camera3D

# State
var current_zoom: float
var current_rotation: int = 1  # In 45Â° increments (0-7)

# ============================================================================
# LIFECYCLE
# ============================================================================

func _ready() -> void:
	# Configure SpringArm for collision
	spring_arm.spring_length = default_distance
	spring_arm.collision_mask = 2  # Walls on layer 2

	# Set initial angles
	v_pivot.rotation_degrees.x = default_pitch
	h_pivot.rotation_degrees.y = default_yaw

	current_zoom = default_distance
	current_rotation = int(default_yaw / rotation_snap)

	# Camera settings
	camera.fov = 70.0  # Field of view

	print("[TacticalCamera] Initialized - Zoom: %.1f, Rotation: %dÂ°" % [
		current_zoom,
		current_rotation * int(rotation_snap)
	])

func _unhandled_input(event: InputEvent) -> void:
	# Zoom controls
	if event.is_action("camera_zoom_in"):
		zoom(-zoom_speed)
		get_viewport().set_input_as_handled()
	elif event.is_action("camera_zoom_out"):
		zoom(zoom_speed)
		get_viewport().set_input_as_handled()

	# Rotation controls
	if event.is_action_pressed("camera_rotate_left"):
		rotate_camera(-1)
		get_viewport().set_input_as_handled()
	elif event.is_action_pressed("camera_rotate_right"):
		rotate_camera(1)
		get_viewport().set_input_as_handled()

# ============================================================================
# CAMERA CONTROLS
# ============================================================================

func zoom(delta: float) -> void:
	"""Adjust camera distance"""
	current_zoom = clampf(current_zoom + delta, zoom_min, zoom_max)
	spring_arm.spring_length = current_zoom

	# Adjust pitch based on zoom (like RTS games)
	# More zoomed out = steeper angle for tactical view
	var zoom_ratio = (current_zoom - zoom_min) / (zoom_max - zoom_min)
	var target_pitch = lerp(pitch_near, pitch_far, zoom_ratio)
	v_pivot.rotation_degrees.x = target_pitch

func rotate_camera(direction: int) -> void:
	"""Rotate camera in 45Â° increments"""
	current_rotation = wrapi(current_rotation + direction, 0, 8)

	# Smooth rotation
	var target_angle = current_rotation * rotation_snap
	var tween = create_tween()
	tween.tween_property(h_pivot, "rotation_degrees:y", target_angle, 0.3)\
		.set_trans(Tween.TRANS_CUBIC)\
		.set_ease(Tween.EASE_OUT)

# ============================================================================
# UTILITY
# ============================================================================

func get_camera_forward() -> Vector3:
	"""Get forward direction in world space (for aiming)"""
	return -camera.global_transform.basis.z

func get_camera_right() -> Vector3:
	"""Get right direction in world space"""
	return camera.global_transform.basis.x
```

### 2.3 Add Camera Input Actions

**Modify**: `/project.godot`

Add to `[input]` section:

```gdscript
camera_zoom_in={
"deadzone": 0.5,
"events": [Object(InputEventMouseButton,"button_index":4), Object(InputEventJoypadButton,"button_index":4)]
}
camera_zoom_out={
"deadzone": 0.5,
"events": [Object(InputEventMouseButton,"button_index":5), Object(InputEventJoypadButton,"button_index":5)]
}
camera_rotate_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"physical_keycode":81), Object(InputEventJoypadButton,"button_index":9)]
}
camera_rotate_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"physical_keycode":69), Object(InputEventJoypadButton,"button_index":10)]
}
```

**Keys**:
- `Q` / Left Stick Click = Rotate Left
- `E` / Right Stick Click = Rotate Right
- Mouse Wheel / LB/RB = Zoom In/Out

### 2.4 Attach Camera Script

In `game_3d.tscn`:
1. Select `Player3D/CameraRig` node
2. Attach script: `tactical_camera.gd`
3. Configure in Inspector:
   - Default Distance: 15
   - Default Pitch: -45
   - Default Yaw: 45
   - Zoom Min: 8
   - Zoom Max: 25

### 2.5 Testing Checklist

- [ ] Camera follows player smoothly
- [ ] Mouse wheel zooms in/out (8-25 units)
- [ ] Q/E rotates camera in 45Â° increments
- [ ] Camera doesn't clip through walls (SpringArm3D)
- [ ] Pitch angle adjusts with zoom (steeper when far)
- [ ] Controller shoulder buttons zoom
- [ ] Stick clicks rotate camera

**Expected Result**: Smooth Fortnite-style third-person camera with tactical controls.

---

## Phase 3: PSX Shader Integration

### 3.1 Download MenacingMecha's PSX Shaders

**Source**: https://github.com/MenacingMecha/godot-psx-style-demo

**Steps**:
1. Clone or download the repository
2. Copy these folders to your project:
   ```
   shaders/ â†’ res://shaders/
   post_process/ â†’ res://post_process/
   ```

**Files you need**:
```
res://shaders/
â”œâ”€ psx_base.gdshaderinc        # Core implementation
â”œâ”€ psx_lit.gdshader            # Lit material
â”œâ”€ psx_unlit.gdshader          # Unlit material
â””â”€ pp_band-dither.gdshader     # Post-processing dither
```

### 3.2 Configure Project for PSX

**Modify**: `project.godot`

Add to `[shader_globals]` section:

```gdscript
precision_multiplier={
"type": "float",
"value": 0.5
}
```

**Modify**: Display settings

```gdscript
[display]
window/size/viewport_width=320
window/size/viewport_height=240
window/size/mode=2  # Fullscreen or windowed
window/stretch/mode="viewport"
```

**Modify**: Rendering settings

```gdscript
[rendering]
textures/canvas_textures/default_texture_filter=0  # Nearest neighbor
```

### 3.3 Create PSX Materials

**New file**: Create in Godot Editor

**Floor Material**:
1. Create new ShaderMaterial: `res://assets/materials/psx_floor.tres`
2. Shader: Load `res://shaders/psx_lit.gdshader`
3. Parameters:
   - Albedo Texture: Create simple 64x64 brown texture
   - Texture Filter: Nearest
   - Enable affine mapping: true
   - Enable vertex jitter: true

**Wall Material**:
1. Create new ShaderMaterial: `res://assets/materials/psx_wall.tres`
2. Shader: Load `res://shaders/psx_lit.gdshader`
3. Parameters:
   - Albedo Texture: Create 64x64 yellow wallpaper texture
   - Texture Filter: Nearest
   - Enable affine mapping: true
   - Enable vertex jitter: true

### 3.4 Apply Materials to MeshLibrary

**Modify**: `res://assets/mesh_library.tscn`

1. Open mesh_library scene
2. Select Floor MeshInstance3D
   - Material Override: Load `psx_floor.tres`
3. Select Wall MeshInstance3D
   - Material Override: Load `psx_wall.tres`
4. Re-export as MeshLibrary

### 3.5 Add Dithering Post-Process

**New scene**: `res://scenes/post_process.tscn`

```
ColorRect (Post Process)
â”œâ”€ Material: ShaderMaterial
â”‚  â””â”€ Shader: res://shaders/pp_band-dither.gdshader
â””â”€ Anchors: Full Rect (covers screen)
```

**Add to game_3d.tscn**:
```
Game (Node3D)
â””â”€ UI (CanvasLayer)
   â”œâ”€ PostProcess (ColorRect) - NEW
   â”œâ”€ TurnCounter (Label)
   â””â”€ Instructions (Label)
```

### 3.6 Testing Checklist

- [ ] Textures appear pixelated (nearest filter)
- [ ] Vertex wobble visible when moving camera
- [ ] Textures warp at oblique angles (affine mapping)
- [ ] Dithering visible in gradients
- [ ] Overall "PS1 look" achieved

**Expected Result**: Game looks like a PS1 game - wobbly geometry, warping textures, low-res.

---

## Phase 4: Backrooms Environment

### 4.1 Create Backrooms Textures

**New textures** (create in image editor or find):

**Yellow Wallpaper** (`res://assets/textures/backrooms_wallpaper.png`):
- Size: 128Ã—128 or 64Ã—64
- Color: `#E8D998` (mono-yellow)
- Pattern: Slight noise or subtle vertical lines
- Posterize to 15-bit color depth

**Brown Carpet** (`res://assets/textures/backrooms_carpet.png`):
- Size: 128Ã—128
- Color: `#5C4033` (brown)
- Pattern: Subtle carpet texture
- Add slight normal map for depth

**Ceiling Tile** (`res://assets/textures/ceiling_tile.png`):
- Size: 64Ã—64
- Color: Off-white `#F5F5DC`
- Pattern: Grid lines (office ceiling tiles)

**Import Settings** for all textures:
- Filter: Nearest
- Mipmaps: Disabled
- Repeat: Enabled

### 4.2 Update Materials

**Modify**: PSX materials created in Phase 3

**psx_wall.tres**:
- Albedo Texture: `backrooms_wallpaper.png`
- Vertex Color: Slight yellow tint

**psx_floor.tres**:
- Albedo Texture: `backrooms_carpet.png`
- Add Normal Map: Create slight bump

**psx_ceiling.tres** (new):
- Shader: `psx_unlit.gdshader` (ceilings don't need lighting)
- Albedo Texture: `ceiling_tile.png`

### 4.3 Add Fluorescent Lighting

**New script**: `/scripts/environment/fluorescent_light.gd`

```gdscript
extends OmniLight3D
## Backrooms fluorescent light with flickering effect

@export var flicker_enabled: bool = true
@export var flicker_chance: float = 0.001  # Per frame
@export var base_energy: float = 1.0

var original_energy: float

func _ready() -> void:
	original_energy = light_energy
	light_color = Color("#FFFACD")  # Yellowish white
	omni_range = 8.0
	shadow_enabled = true

func _process(_delta: float) -> void:
	if not flicker_enabled:
		return

	# Random flicker
	if randf() < flicker_chance:
		_flicker()

func _flicker() -> void:
	"""Brief flicker effect"""
	var tween = create_tween()
	tween.tween_property(self, "light_energy", 0.2, 0.05)
	tween.tween_property(self, "light_energy", original_energy, 0.05)
```

**Add to Grid3D**:

```gdscript
# In Grid3D._generate_grid():
func _add_ceiling_lights() -> void:
	"""Add fluorescent lights in grid pattern"""
	const LIGHT_SPACING := 4  # Every 4 tiles

	for y in range(0, grid_size.y, LIGHT_SPACING):
		for x in range(0, grid_size.x, LIGHT_SPACING):
			if not is_walkable(Vector2i(x, y)):
				continue  # Don't put lights in walls

			var light = preload("res://scenes/fluorescent_light.tscn").instantiate()
			var light_pos = grid_to_world(Vector2i(x, y))
			light_pos.y = 2.5  # Ceiling height
			light.global_position = light_pos
			add_child(light)
```

### 4.4 Add Volumetric Fog

**Modify**: `WorldEnvironment` node in game_3d.tscn

Create Environment resource with:

```
Environment Settings:
â”œâ”€ Background
â”‚  â””â”€ Mode: Sky (or Color with slight yellow)
â”œâ”€ Volumetric Fog
â”‚  â”œâ”€ Enabled: true
â”‚  â”œâ”€ Density: 0.01 (subtle)
â”‚  â”œâ”€ Albedo: Color(0.98, 0.98, 0.95) - slight yellow tint
â”‚  â”œâ”€ Emission Energy: 0.0
â”‚  â””â”€ Length: 64.0
â”œâ”€ Adjustments
â”‚  â”œâ”€ Contrast: 1.2
â”‚  â””â”€ Saturation: 1.3
â””â”€ Glow (optional)
   â”œâ”€ Enabled: true
   â””â”€ Intensity: 0.3 (subtle bloom on lights)
```

### 4.5 Add Ambient Sound

**New file**: `res://audio/fluorescent_buzz.ogg`

Find or create:
- 60Hz electrical hum
- Constant, monotonous
- Loop seamlessly

**Add to Game scene**:

```
Game (Node3D)
â””â”€ AmbientSound (AudioStreamPlayer)
   â”œâ”€ Stream: fluorescent_buzz.ogg
   â”œâ”€ Autoplay: true
   â”œâ”€ Volume: -12 dB (background level)
   â””â”€ Bus: "Ambient"
```

### 4.6 Testing Checklist

- [ ] Walls are mono-yellow (liminal feel)
- [ ] Floor is brown carpet texture
- [ ] Ceiling has tile pattern
- [ ] Lights emit yellowish glow
- [ ] Occasional light flickers
- [ ] Volumetric fog creates haze
- [ ] Ambient buzz audible but not overwhelming
- [ ] Overall "endless office" vibe

**Expected Result**: Backrooms Level 0 aesthetic - eerie, yellow, fluorescent-lit hallways.

---

## Phase 5: Billboard Characters

### 5.1 Convert Player to Sprite3D

**Modify**: `Player3D` scene structure

```
Player3D (CharacterBody3D)
â”œâ”€ CollisionShape3D (CapsuleShape3D, height=1.8, radius=0.4)
â”œâ”€ Model (Sprite3D) - NEW SETUP
â”‚  â””â”€ Script: player_sprite.gd
â””â”€ CameraRig (...)
```

### 5.2 Create Player Sprite Script

**New file**: `/scripts/player/player_sprite.gd`

```gdscript
extends Sprite3D
## Player visual - emoji billboard sprite

@export var walk_animation_speed: float = 4.0

var is_walking: bool = false

func _ready() -> void:
	# Billboard configuration
	billboard = BaseMaterial3D.BILLBOARD_FIXED_Y  # Stay upright

	# Sprite properties
	pixel_size = 0.01  # Adjust for size
	alpha_cut = ALPHA_CUT_OPAQUE_PREPASS
	texture_filter = BaseMaterial3D.TEXTURE_FILTER_NEAREST

	# Set emoji texture
	# For now, use Label3D or create texture from emoji
	# TODO: Create actual sprite sheet

func set_walking(walking: bool) -> void:
	"""Set walking animation state"""
	is_walking = walking

	# TODO: Swap between idle/walk sprite frames
```

### 5.3 Create Emoji Texture

**Option A: Label3D** (Quick)

Replace Sprite3D with Label3D temporarily:

```gdscript
extends Label3D

func _ready():
	text = "ðŸš¶"
	font_size = 64
	billboard = BaseMaterial3D.BILLBOARD_FIXED_Y
```

**Option B: Proper Sprite** (Better)

1. Create emoji images in image editor:
   - `player_idle.png` - ðŸš¶ emoji at 128Ã—128
   - `player_walk.png` - ðŸš¶ emoji at 128Ã—128
2. Import with Nearest filter
3. Assign to Sprite3D texture

### 5.4 Update Player Movement to Animate

**Modify**: `/scripts/player/player_3d.gd`

```gdscript
func _process(delta: float) -> void:
	# ... existing code ...

	# Update sprite animation
	if is_moving:
		model.set_walking(true)
	else:
		model.set_walking(false)
```

### 5.5 Add Enemy Placeholder

**New scene**: `res://scenes/enemy.tscn`

```
Enemy (CharacterBody3D)
â”œâ”€ CollisionShape3D
â””â”€ Model (Sprite3D)
   â””â”€ Texture: "ðŸ‘¹" emoji or sprite
   â””â”€ Billboard: FIXED_Y
```

Spawn a few in Grid3D for testing:

```gdscript
# In Grid3D._ready():
func _spawn_test_enemies():
	for i in range(5):
		var enemy = preload("res://scenes/enemy.tscn").instantiate()
		var pos = get_random_walkable_position()
		enemy.global_position = grid_to_world(pos)
		add_child(enemy)
```

### 5.6 Testing Checklist

- [ ] Player sprite visible and upright
- [ ] Billboard always faces camera
- [ ] Sprite scales correctly in 3D space
- [ ] Nearest filter makes it pixelated (PSX style)
- [ ] Enemies also visible as billboards
- [ ] Characters don't rotate with camera

**Expected Result**: PaRappa-style flat characters in 3D world.

---

## Phase 6: VHS Post-Processing

### 6.1 Download VHS Shader

**Source**: https://godotshaders.com/shader/vhs-post-processing/

**New file**: `res://shaders/vhs_post_process.gdshader`

Copy the shader code from GodotShaders.com (Room2Room VHS shader).

### 6.2 Create VHS Post-Process Scene

**New scene**: `res://scenes/vhs_overlay.tscn`

```
ColorRect (VHS Overlay)
â”œâ”€ Layout: Full Rect
â”œâ”€ Material: ShaderMaterial
â”‚  â””â”€ Shader: vhs_post_process.gdshader
â””â”€ Script: vhs_controller.gd
```

### 6.3 Create VHS Controller Script

**New file**: `/scripts/effects/vhs_controller.gd`

```gdscript
extends ColorRect
## VHS post-processing controller
##
## Applies analog horror effects: scanlines, grain, chromatic aberration

@export_range(0.0, 1.0) var intensity: float = 0.7
@export var enable_scanlines: bool = true
@export var enable_grain: bool = true
@export var enable_chromatic_aberration: bool = true

var shader_mat: ShaderMaterial

func _ready() -> void:
	shader_mat = material as ShaderMaterial
	_update_shader_params()

func _update_shader_params() -> void:
	"""Update shader parameters based on settings"""
	if not shader_mat:
		return

	# Adjust parameters based on intensity
	shader_mat.set_shader_parameter("scanline_strength", 0.3 * intensity)
	shader_mat.set_shader_parameter("grain_amount", 0.1 * intensity)
	shader_mat.set_shader_parameter("aberration_amount", 0.002 * intensity)

	# Toggle features
	shader_mat.set_shader_parameter("scanlines_enabled", enable_scanlines)
	shader_mat.set_shader_parameter("grain_enabled", enable_grain)
	shader_mat.set_shader_parameter("aberration_enabled", enable_chromatic_aberration)

func set_intensity(value: float) -> void:
	"""Adjust overall effect intensity (0.0-1.0)"""
	intensity = clampf(value, 0.0, 1.0)
	_update_shader_params()
```

### 6.4 Add to Game Scene

**Modify**: `game_3d.tscn`

Add VHS overlay to UI CanvasLayer:

```
Game (Node3D)
â””â”€ UI (CanvasLayer)
   â”œâ”€ VHSOverlay (instance of vhs_overlay.tscn) - ABOVE OTHER UI
   â”œâ”€ PostProcess (ColorRect) - PSX dither
   â”œâ”€ TurnCounter (Label)
   â””â”€ Instructions (Label)
```

**Layer order** (bottom to top):
1. TurnCounter, Instructions (gameplay UI)
2. PostProcess (PSX dither)
3. VHSOverlay (VHS effects)

### 6.5 Add Settings Toggle

**In options menu** (future):

```gdscript
# Allow player to adjust VHS intensity
var vhs_overlay = get_node("/root/Game/UI/VHSOverlay")
vhs_overlay.set_intensity(0.5)  # 0.0 = off, 1.0 = full
```

### 6.6 Testing Checklist

- [ ] Scanlines visible across screen
- [ ] Film grain animates (noise)
- [ ] Chromatic aberration at edges (RGB split)
- [ ] Effect adjustable via intensity parameter
- [ ] UI text still readable
- [ ] Gameplay elements visible through effect
- [ ] Can toggle off for accessibility

**Expected Result**: Found footage VHS aesthetic layered over PSX graphics.

---

## Phase 7: Procedural Generation

### 7.1 Design Hallway Generation System

**Algorithm**: Random walk with backtracking

```
1. Start at center position
2. Pick random cardinal direction (N/E/S/W)
3. Place hallway segment in that direction
4. 80% chance: continue in same direction
5. 20% chance: turn 90Â° left or right
6. Every 10-15 segments: branch off (create T-junction)
7. Stop after N segments (e.g., 500 for large level)
8. Fill remaining space with dead-end rooms
```

### 7.2 Create Procedural Generator Script

**New file**: `/scripts/procedural/backrooms_generator.gd`

```gdscript
class_name BackroomsGenerator
extends RefCounted
## Procedural generator for Backrooms-style hallways

const HALLWAY_MIN_LENGTH := 3
const HALLWAY_MAX_LENGTH := 10
const BRANCH_CHANCE := 0.15
const TURN_CHANCE := 0.2

enum Direction { NORTH, EAST, SOUTH, WEST }

var grid_size: Vector2i
var walkable_cells: Array[Vector2i] = []
var wall_cells: Array[Vector2i] = []

func generate(size: Vector2i) -> Dictionary:
	"""Generate Backrooms level layout"""
	grid_size = size
	walkable_cells.clear()
	wall_cells.clear()

	# Start at center
	var start_pos = Vector2i(size.x / 2, size.y / 2)

	# Generate main path
	_generate_path(start_pos, Direction.NORTH, 500)

	# Add some rooms
	_add_random_rooms(10)

	# Fill in walls (anything not walkable)
	_compute_walls()

	return {
		"walkable": walkable_cells,
		"walls": wall_cells
	}

func _generate_path(start: Vector2i, initial_dir: Direction, segments: int) -> void:
	"""Generate winding hallway path"""
	var pos = start
	var dir = initial_dir

	for i in range(segments):
		# Place hallway segment
		var length = randi_range(HALLWAY_MIN_LENGTH, HALLWAY_MAX_LENGTH)
		pos = _place_hallway(pos, dir, length)

		# Decide next direction
		if randf() < TURN_CHANCE:
			# Turn 90Â°
			dir = _random_perpendicular(dir)

		# Occasionally branch
		if randf() < BRANCH_CHANCE:
			var branch_dir = _random_perpendicular(dir)
			_generate_path(pos, branch_dir, segments / 4)  # Shorter branch

func _place_hallway(start: Vector2i, dir: Direction, length: int) -> Vector2i:
	"""Place hallway tiles in direction"""
	var pos = start
	var delta = _direction_to_vector(dir)

	for i in range(length):
		if _is_in_bounds(pos):
			if not pos in walkable_cells:
				walkable_cells.append(pos)
		pos += delta

	return pos

func _add_random_rooms(count: int) -> void:
	"""Add small rooms connected to hallways"""
	for i in range(count):
		var hallway_pos = walkable_cells.pick_random()
		var room_size = Vector2i(randi_range(3, 6), randi_range(3, 6))

		# Place room
		for y in range(room_size.y):
			for x in range(room_size.x):
				var pos = hallway_pos + Vector2i(x - room_size.x / 2, y - room_size.y / 2)
				if _is_in_bounds(pos) and not pos in walkable_cells:
					walkable_cells.append(pos)

func _compute_walls() -> void:
	"""Fill grid with walls where not walkable"""
	for y in range(grid_size.y):
		for x in range(grid_size.x):
			var pos = Vector2i(x, y)
			if not pos in walkable_cells:
				wall_cells.append(pos)

func _direction_to_vector(dir: Direction) -> Vector2i:
	match dir:
		Direction.NORTH: return Vector2i(0, -1)
		Direction.EAST: return Vector2i(1, 0)
		Direction.SOUTH: return Vector2i(0, 1)
		Direction.WEST: return Vector2i(-1, 0)
	return Vector2i.ZERO

func _random_perpendicular(dir: Direction) -> Direction:
	"""Get random perpendicular direction"""
	match dir:
		Direction.NORTH, Direction.SOUTH:
			return Direction.EAST if randf() > 0.5 else Direction.WEST
		Direction.EAST, Direction.WEST:
			return Direction.NORTH if randf() > 0.5 else Direction.SOUTH
	return dir

func _is_in_bounds(pos: Vector2i) -> bool:
	return pos.x >= 0 and pos.x < grid_size.x and \
	       pos.y >= 0 and pos.y < grid_size.y
```

### 7.3 Integrate with Grid3D

**Modify**: `/scripts/grid_3d.gd`

```gdscript
func _generate_grid() -> void:
	"""Generate 3D grid using procedural generator"""
	var generator = BackroomsGenerator.new()
	var layout = generator.generate(grid_size)

	# Place floors
	for pos in layout["walkable"]:
		grid_map.set_cell_item(Vector3i(pos.x, 0, pos.y), TileType.FLOOR)
		walkable_cells.append(pos)

	# Place walls
	for pos in layout["walls"]:
		grid_map.set_cell_item(Vector3i(pos.x, 0, pos.y), TileType.WALL)

	print("[Grid3D] Generated Backrooms: %d walkable tiles" % walkable_cells.size())
```

### 7.4 Add Chunk Loading (Optional)

**For performance with large grids**:

```gdscript
# In Grid3D
const CHUNK_SIZE := 32
const LOAD_DISTANCE := 64  # Load chunks within this distance

var loaded_chunks: Dictionary = {}  # Vector2i â†’ Array[tiles]

func _process(_delta: float) -> void:
	_update_chunk_loading()

func _update_chunk_loading() -> void:
	"""Load/unload chunks based on player position"""
	var player_pos = get_node("/root/Game/Player3D").grid_position
	var player_chunk = Vector2i(player_pos.x / CHUNK_SIZE, player_pos.y / CHUNK_SIZE)

	# Load nearby chunks
	for dy in range(-2, 3):
		for dx in range(-2, 3):
			var chunk_pos = player_chunk + Vector2i(dx, dy)
			if not chunk_pos in loaded_chunks:
				_load_chunk(chunk_pos)

	# Unload distant chunks
	for chunk_pos in loaded_chunks.keys():
		var distance = (chunk_pos - player_chunk).length()
		if distance > 3:
			_unload_chunk(chunk_pos)

func _load_chunk(chunk_pos: Vector2i) -> void:
	"""Load chunk at position"""
	# Generate or load tiles for this chunk
	pass

func _unload_chunk(chunk_pos: Vector2i) -> void:
	"""Unload chunk at position"""
	loaded_chunks.erase(chunk_pos)
```

### 7.5 Testing Checklist

- [ ] Procedural hallways generated
- [ ] Hallways wind and branch naturally
- [ ] No disconnected sections (all reachable)
- [ ] Occasional rooms for variety
- [ ] Performance acceptable (60 FPS)
- [ ] Feels endless and maze-like
- [ ] Chunk loading works if implemented

**Expected Result**: Infinite-feeling yellow hallways, procedurally generated.

---

## Phase 8: Polish & Balance

### 8.1 Visibility Tuning

**Test with both effects active**:

- PSX vertex jitter + affine textures
- VHS scanlines + grain + aberration

**Adjust**:

```gdscript
# In vhs_controller.gd
# Reduce intensity for gameplay clarity
intensity = 0.5  # Start here, tune based on feedback

# In tactical_camera.gd
# Ensure camera angle shows grid clearly
default_pitch = -50.0  # Steeper = more tactical
```

**Add high-contrast option**:

```gdscript
# In Grid3D or separate script
func enable_high_contrast_mode(enabled: bool) -> void:
	"""Outline important gameplay elements"""
	if enabled:
		# Add subtle outline shader to enemies/items
		# Brighten player model
		# Increase light energy slightly
		pass
```

### 8.2 Performance Optimization

**Profile with Godot profiler**:

- Target: 60 FPS on mid-range hardware
- Monitor: Draw calls, vertex count, shader compile time

**Optimizations**:

1. **Reduce light count**:
   ```gdscript
   # In Grid3D._add_ceiling_lights()
   const LIGHT_SPACING := 6  # Increase from 4
   ```

2. **Use lightmaps** (future):
   - Bake static lighting into textures
   - Keep only a few dynamic lights

3. **LOD for distant characters**:
   ```gdscript
   # In player_sprite.gd
   func _process(_delta):
       var camera_distance = global_position.distance_to(camera.global_position)
       if camera_distance > 30.0:
           visible = false  # Or swap to lower-res sprite
       else:
           visible = true
   ```

4. **Limit shader complexity**:
   - Disable affine mapping on distant objects
   - Reduce VHS effect intensity when moving fast

### 8.3 UI Polish

**Add PSX-style UI**:

```gdscript
# In UI labels
theme_override_fonts/font = preload("res://assets/fonts/psx_font.ttf")
theme_override_font_sizes/font_size = 8  # Small, pixelated
theme_override_colors/font_color = Color(0.9, 0.9, 0.9)
```

**Add minimap** (optional):

```
UI (CanvasLayer)
â””â”€ Minimap (Control)
   â””â”€ ViewportContainer
      â””â”€ SubViewport
         â””â”€ MinimapCamera (Camera3D, orthogonal, top-down)
```

### 8.4 Audio Balance

**Mix levels**:
- Fluorescent buzz: -15 dB (background)
- Footsteps: -8 dB (clear but not loud)
- Enemy sounds: -6 dB (important cues)
- UI sounds: -10 dB (feedback)

**Add audio buses**:

```
Master
â”œâ”€ Music (-6 dB)
â”œâ”€ SFX (-3 dB)
â”‚  â”œâ”€ Player
â”‚  â””â”€ Enemies
â”œâ”€ Ambient (-12 dB)
â”‚  â””â”€ Fluorescent buzz
â””â”€ UI (-6 dB)
```

### 8.5 Accessibility Options

**Add settings menu**:

```gdscript
# Settings.gd
var vhs_intensity: float = 0.7
var vertex_jitter_enabled: bool = true
var brightness_boost: float = 0.0
var high_contrast_mode: bool = false

func apply_settings() -> void:
	# VHS
	var vhs = get_node("/root/Game/UI/VHSOverlay")
	vhs.set_intensity(vhs_intensity)

	# PSX jitter
	var precision = 0.5 if vertex_jitter_enabled else 1.0
	RenderingServer.global_shader_parameter_set("precision_multiplier", precision)

	# Brightness
	var env = get_node("/root/Game/WorldEnvironment").environment
	env.adjustment_brightness = 1.0 + brightness_boost

	# Contrast mode
	var grid = get_node("/root/Game/Grid3D")
	grid.enable_high_contrast_mode(high_contrast_mode)
```

### 8.6 Final Testing Checklist

**Visual**:
- [ ] PSX + VHS effects balanced
- [ ] Enemies clearly visible
- [ ] Items distinguishable from background
- [ ] Text readable
- [ ] No motion sickness from vertex wobble

**Gameplay**:
- [ ] Turn-based feel preserved
- [ ] Camera controls intuitive
- [ ] Movement feels responsive
- [ ] Combat (when added) is clear
- [ ] Navigation not frustrating

**Performance**:
- [ ] Solid 60 FPS
- [ ] No stuttering during chunk loading
- [ ] Memory usage reasonable (<512MB)
- [ ] Shader compilation smooth

**Atmosphere**:
- [ ] Liminal horror feel achieved
- [ ] Backrooms aesthetic recognizable
- [ ] PSX nostalgia without being gimmick
- [ ] VHS effect enhances, doesn't hinder

**Expected Result**: Polished 2.5D PSX Backrooms roguelike ready for gameplay systems.

---

## Architecture Preservation

### What Stays the Same

**InputManager** âœ…
- 8-way grid direction works identically
- `get_aim_direction_grid()` returns Vector2i (unchanged)
- Trigger support works same way
- Only addition: Camera control input handling

**State Machine** âœ…
- IdleState, AimingMoveState, ExecutingTurnState unchanged
- State transitions identical
- Turn boundaries preserved
- Only change: Adapted to 3D player node

**Action System** âœ…
- `MovementAction`, `WaitAction` work identically
- `can_execute()` uses Vector2i grid positions (unchanged)
- `execute()` updates `grid_position` (unchanged)
- Player converts grid position to 3D visually

**Turn-Based Logic** âœ…
- Turn counter works same
- Action queue (future) will work same
- Enemy turns (future) will work same

### What Changes

**Grid Rendering**:
- Before: Label nodes in Node2D
- After: GridMap with MeshInstance3D

**Player Visual**:
- Before: Label with emoji
- After: Sprite3D billboard with emoji texture

**Camera**:
- Before: Camera2D top-down
- After: Camera3D third-person with rig

**Coordinate Conversion**:
- Before: `Vector2i` â†’ `Vector2`
- After: `Vector2i` â†’ `Vector3` (simple mapping)

---

## Implementation Timeline

**Estimated time**: 2-3 weeks for full conversion

### Week 1: 3D Foundation
- **Day 1-2**: Phase 1 (GridMap, Grid3D, coordinate conversion)
- **Day 3-4**: Phase 2 (Camera rig, controls)
- **Day 5**: Testing and debugging

### Week 2: Visual Style
- **Day 1-2**: Phase 3 (PSX shaders)
- **Day 3-4**: Phase 4 (Backrooms environment, lighting)
- **Day 5**: Phase 5 (Billboard characters)

### Week 3: Effects & Polish
- **Day 1-2**: Phase 6 (VHS post-processing)
- **Day 3**: Phase 7 (Procedural generation)
- **Day 4-5**: Phase 8 (Polish, optimization, balance)

**Contingency**: +1 week for unexpected issues

---

## Risk Mitigation

### Potential Issues

**1. Performance with PSX + VHS shaders**
- **Risk**: Combined shader cost too high
- **Mitigation**: Profile early, optimize or reduce effects
- **Fallback**: Make VHS optional, reduce resolution

**2. Vertex jitter causes motion sickness**
- **Risk**: Some players sensitive to wobble
- **Mitigation**: Reduce `precision_multiplier` to 0.7 or 0.8
- **Fallback**: Accessibility option to disable

**3. Procedural generation creates impossible layouts**
- **Risk**: Dead ends, unreachable areas
- **Mitigation**: Test generation algorithm thoroughly
- **Fallback**: Use simpler grid-based generation

**4. Turn-based gameplay feels wrong in 3D**
- **Risk**: Players expect real-time in third-person
- **Mitigation**: Clear visual feedback for turn boundaries
- **Fallback**: Add optional "continuous movement" mode

**5. Backrooms aesthetic too oppressive for roguelike**
- **Risk**: Endless yellow halls become boring
- **Mitigation**: Add color variation in later levels
- **Fallback**: "Level 1" with different aesthetic

---

## Success Criteria

### MVP (Minimum Viable Product)

- [ ] 3D grid with working turn-based movement
- [ ] Third-person camera with basic controls
- [ ] PSX visual style (jitter + affine textures)
- [ ] Yellow hallways with fluorescent lights
- [ ] Billboard emoji characters
- [ ] 60 FPS performance

### Full Implementation

- [ ] All MVP criteria met
- [ ] VHS post-processing applied
- [ ] Procedural generation working
- [ ] Chunk loading for performance
- [ ] Audio (buzz, footsteps, ambience)
- [ ] Accessibility options
- [ ] Polish and balance complete

### Stretch Goals

- [ ] Multiple Backrooms levels (0, 1, 2...)
- [ ] Dynamic lighting (lights turn off/on)
- [ ] Advanced VHS effects (glitch transitions)
- [ ] Realtime reflection probes
- [ ] Photorealistic water puddles (with PSX twist)

---

## Next Steps

1. **Review this plan** - Confirm approach before starting
2. **Set up test project** - Try PSX shaders in isolated scene
3. **Create Phase 1** - Get basic 3D grid working
4. **Iterate** - Complete one phase at a time, test thoroughly
5. **Commit frequently** - Small commits after each working feature

**Ready to begin?** Start with Phase 1: 3D Foundation.

---

## Appendix: Key Resources

### External Resources

**PSX Shaders**:
- MenacingMecha/godot-psx-style-demo: https://github.com/MenacingMecha/godot-psx-style-demo

**VHS Shader**:
- GodotShaders VHS: https://godotshaders.com/shader/vhs-post-processing/

**Procedural Generation**:
- RodZill4/godot-procedural3d: https://github.com/RodZill4/godot-procedural3d

**Backrooms Reference**:
- Kane Pixels YouTube: https://www.youtube.com/@KanePixels
- Backrooms Wiki: https://backrooms.fandom.com/wiki/Level_0

**Godot Docs**:
- GridMap: https://docs.godotengine.org/en/stable/classes/class_gridmap.html
- Sprite3D: https://docs.godotengine.org/en/stable/classes/class_sprite3d.html
- Camera3D: https://docs.godotengine.org/en/stable/classes/class_camera3d.html

### Project Files (After Implementation)

```
/scenes/
â”œâ”€ game_3d.tscn           # Main 3D game scene
â”œâ”€ vhs_overlay.tscn       # VHS post-process
â””â”€ fluorescent_light.tscn # Light prefab

/scripts/
â”œâ”€ grid_3d.gd             # 3D grid system
â”œâ”€ player/
â”‚  â”œâ”€ player_3d.gd        # 3D player controller
â”‚  â”œâ”€ player_sprite.gd    # Billboard sprite
â”‚  â””â”€ tactical_camera.gd  # Camera controller
â”œâ”€ procedural/
â”‚  â””â”€ backrooms_generator.gd  # Level generation
â””â”€ effects/
   â”œâ”€ vhs_controller.gd   # VHS effect manager
   â””â”€ fluorescent_light.gd # Flickering light

/shaders/
â”œâ”€ psx_base.gdshaderinc   # PSX core
â”œâ”€ psx_lit.gdshader       # PSX lit material
â”œâ”€ psx_unlit.gdshader     # PSX unlit material
â”œâ”€ pp_band-dither.gdshader # Dithering
â””â”€ vhs_post_process.gdshader # VHS effect

/assets/
â”œâ”€ textures/
â”‚  â”œâ”€ backrooms_wallpaper.png
â”‚  â”œâ”€ backrooms_carpet.png
â”‚  â””â”€ ceiling_tile.png
â”œâ”€ materials/
â”‚  â”œâ”€ psx_floor.tres
â”‚  â”œâ”€ psx_wall.tres
â”‚  â””â”€ psx_ceiling.tres
â””â”€ grid_mesh_library.tres

/audio/
â””â”€ fluorescent_buzz.ogg
```

---

**End of Plan** - Ready for implementation!
